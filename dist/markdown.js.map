{"version":3,"sources":["../node_modules/indented-filter/dist/eqdict.js","../node_modules/indented-filter/dist/util.js","../node_modules/indented-filter/dist/index.js","../node_modules/browser-split/index.js","../node_modules/indexof/index.js","../node_modules/class-list/index.js","../node_modules/hyperscript/index.js","markdown.ts"],"names":[],"mappings":";AAAA,aACA,IAAA,EAAA,MAAA,KAAA,QAAA,SAAA,EAAA,GACA,IAAA,EAAA,mBAAA,QAAA,EAAA,OAAA,UACA,IAAA,EAAA,OAAA,EACA,IAAA,EAAA,EAAA,EAAA,EAAA,KAAA,GAAA,EAAA,GACA,IACA,WAAA,IAAA,GAAA,KAAA,MAAA,EAAA,EAAA,QAAA,MAAA,EAAA,KAAA,EAAA,OAEA,MAAA,GAAA,EAAA,CAAA,MAAA,GACA,QACA,IACA,IAAA,EAAA,OAAA,EAAA,EAAA,SAAA,EAAA,KAAA,GAEA,QAAA,GAAA,EAAA,MAAA,EAAA,OAEA,OAAA,GAGA,SAAA,EAAA,GAKA,IAJA,IAAA,EAAA,EACA,EAAA,GACA,EAAA,GACA,EAAA,GACA,EAAA,OAAA,GACA,GAAA,EAAA,EAAA,EAAA,GAAA,IAAA,GAAA,EAAA,EAAA,GACA,IACA,MAAA,EAAA,IACA,GAAA,EAAA,EAAA,EAAA,GAAA,IAAA,GAAA,EAAA,EAAA,GACA,EAAA,GAAA,GAGA,EAAA,GAAA,GAEA,EAAA,IAGA,OAAA,EAGA,SAAA,EAAA,GAEA,GADA,EAAA,EAAA,QAAA,YAAA,IAIA,CACA,GAAA,MAAA,EAAA,IAAA,MAAA,EAAA,GAAA,CACA,IAAA,EAAA,EAAA,OAQA,OAPA,EAAA,MAAA,IAAA,QAAA,SAAA,EAAA,GACA,EAAA,GACA,IAAA,EAAA,IAAA,OAAA,EAAA,OAAA,EAAA,EAAA,IAAA,IAAA,EAAA,SACA,EAAA,KAIA,CAAA,EAAA,OAAA,EAAA,EAAA,GAAA,EAAA,OAAA,EAAA,IAGA,IAAA,EAAA,EAAA,OAMA,OALA,EAAA,MAAA,IAAA,QAAA,SAAA,EAAA,GACA,SAAA,KAAA,IAAA,IAAA,EAAA,SACA,EAAA,KAGA,CAAA,EAAA,OAAA,EAAA,GAAA,EAAA,OAAA,IArBA,MAAA,CAAA,GAAA,IAzBA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAqBA,QAAA,aAAA;;ACtCA,aACA,IAAA,EAAA,MAAA,KAAA,UAAA,SAAA,GACA,IAAA,EAAA,mBAAA,QAAA,EAAA,OAAA,UAAA,EAAA,EACA,OAAA,EAAA,EAAA,KAAA,GACA,CACA,KAAA,WAEA,OADA,GAAA,GAAA,EAAA,SAAA,OAAA,GACA,CAAA,MAAA,GAAA,EAAA,KAAA,MAAA,MAIA,EAAA,MAAA,KAAA,QAAA,SAAA,EAAA,GACA,IAAA,EAAA,mBAAA,QAAA,EAAA,OAAA,UACA,IAAA,EAAA,OAAA,EACA,IAAA,EAAA,EAAA,EAAA,EAAA,KAAA,GAAA,EAAA,GACA,IACA,WAAA,IAAA,GAAA,KAAA,MAAA,EAAA,EAAA,QAAA,MAAA,EAAA,KAAA,EAAA,OAEA,MAAA,GAAA,EAAA,CAAA,MAAA,GACA,QACA,IACA,IAAA,EAAA,OAAA,EAAA,EAAA,SAAA,EAAA,KAAA,GAEA,QAAA,GAAA,EAAA,MAAA,EAAA,OAEA,OAAA,GAEA,EAAA,MAAA,KAAA,UAAA,WACA,IAAA,IAAA,EAAA,GAAA,EAAA,EAAA,EAAA,UAAA,OAAA,IAAA,EAAA,EAAA,OAAA,EAAA,UAAA,KACA,OAAA,GAGA,SAAA,EAAA,GACA,IAAA,EAAA,EACA,EAAA,GACA,IACA,IAAA,IAAA,EAAA,EAAA,EAAA,MAAA,OAAA,EAAA,EAAA,QAAA,EAAA,KAAA,EAAA,EAAA,OAAA,CACA,IAAA,EAAA,EAAA,MACA,GAAA,EAAA,OAAA,CACA,IAAA,EAAA,MAAA,KAAA,GACA,GACA,EAAA,KAAA,EAAA,GAAA,UAKA,MAAA,GAAA,EAAA,CAAA,MAAA,GACA,QACA,IACA,IAAA,EAAA,OAAA,EAAA,EAAA,SAAA,EAAA,KAAA,GAEA,QAAA,GAAA,EAAA,MAAA,EAAA,OAEA,IAAA,EAAA,QACA,EAAA,KAAA,GAEA,IAAA,EAAA,KAAA,IAAA,MAAA,KAAA,EAAA,IACA,OAAA,EAAA,MAAA,MAAA,IAAA,SAAA,GAAA,OAAA,EAAA,OAAA,KAAA,KAAA,MA1BA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IA4BA,QAAA,YAAA;;AC3DA,aACA,IAAA,EAAA,MAAA,KAAA,UAAA,SAAA,GACA,IAAA,EAAA,mBAAA,QAAA,EAAA,OAAA,UAAA,EAAA,EACA,OAAA,EAAA,EAAA,KAAA,GACA,CACA,KAAA,WAEA,OADA,GAAA,GAAA,EAAA,SAAA,OAAA,GACA,CAAA,MAAA,GAAA,EAAA,KAAA,MAAA,MAIA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IACA,IAAA,EAAA,QAAA,YACA,EAAA,QAAA,UACA,SAAA,EAAA,EAAA,GACA,OAAA,SAAA,GAKA,IAJA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,GACA,EAAA,EACA,EAAA,EAAA,QAAA,IACA,IAAA,GAAA,CACA,IAAA,EAAA,EAAA,OAAA,EAAA,EAAA,GAAA,MAAA,iBACA,EAAA,EAAA,EAAA,GAAA,OAAA,EACA,EAAA,EAAA,EAAA,OACA,IAAA,EAAA,EAAA,OAAA,GACA,EAAA,EACA,EAAA,GACA,IACA,IAAA,IAAA,GAAA,OAAA,EAAA,EAAA,EAAA,MAAA,MAAA,EAAA,EAAA,QAAA,EAAA,KAAA,EAAA,EAAA,OAAA,CACA,IAAA,EAAA,EAAA,MACA,GAAA,MAAA,GAOA,GAHA,MAAA,GACA,IAEA,EAAA,EACA,EAAA,KAAA,QAEA,GAAA,GAAA,EACA,WAVA,KAcA,MAAA,GAAA,EAAA,CAAA,MAAA,GACA,QACA,IACA,IAAA,EAAA,OAAA,EAAA,EAAA,SAAA,EAAA,KAAA,GAEA,QAAA,GAAA,EAAA,MAAA,EAAA,OAEA,IAAA,EAAA,GACA,GAAA,EAAA,OAAA,EAAA,CACA,IAAA,EAAA,EAAA,KAAA,IACA,EAAA,EAAA,aAAA,GACA,GAAA,EAAA,OAAA,EACA,EAAA,EAAA,OAAA,GAEA,GAAA,MAAA,EAAA,GAAA,CACA,IAAA,GAAA,EACA,EAAA,GACA,IACA,IAAA,IAAA,GAAA,OAAA,EAAA,EAAA,EAAA,MAAA,QAAA,EAAA,EAAA,QAAA,EAAA,KAAA,EAAA,EAAA,OAAA,CACA,IAAA,EAAA,EAAA,MACA,IAAA,EAAA,CACA,GAAA,KAAA,KAAA,KAAA,QAAA,KAAA,EAAA,OAAA,EAAA,EAAA,IAIA,MAHA,EAAA,KAAA,GAMA,GAAA,EAAA,OAAA,EACA,GAAA,GAGA,MAAA,GAAA,EAAA,CAAA,MAAA,GACA,QACA,IACA,IAAA,EAAA,OAAA,EAAA,EAAA,SAAA,EAAA,KAAA,GAEA,QAAA,GAAA,EAAA,MAAA,EAAA,OAEA,EAAA,KAAA,CACA,EAAA,EAAA,YAAA,EAAA,KAAA,OACA,MAAA,EACA,MAAA,EACA,IAAA,QAGA,CACA,IACA,GADA,EAAA,EAAA,MAAA,MAAA,IACA,QAAA,MAGA,IAFA,IAAA,GACA,EAAA,EAAA,OAAA,EAAA,IACA,OAAA,EAGA,EAAA,OAEA,EAAA,KAAA,CACA,EAAA,EAAA,YAAA,GACA,MAAA,EACA,MAAA,EACA,IAAA,IAGA,EAAA,EAAA,QAAA,EAAA,EAAA,GAGA,IAAA,EAAA,GACA,EAAA,EACA,IACA,IAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,QAAA,EAAA,KAAA,EAAA,EAAA,OAAA,CACA,IAAA,EAAA,EAAA,MACA,EAAA,KAAA,EAAA,OAAA,EAAA,EAAA,MAAA,IACA,EAAA,KAAA,EAAA,EAAA,EAAA,EAAA,QACA,EAAA,EAAA,KAGA,MAAA,GAAA,EAAA,CAAA,MAAA,GACA,QACA,IACA,IAAA,EAAA,OAAA,EAAA,EAAA,SAAA,EAAA,KAAA,GAEA,QAAA,GAAA,EAAA,MAAA,EAAA,OAGA,OADA,EAAA,KAAA,EAAA,OAAA,IACA,EAAA,KAAA,KAGA,QAAA,qBAAA;;ACrGA,OAAA,QAAA,SAAA,GAEA,IAAA,EAAA,OAAA,UAAA,MACA,EAAA,OAAA,KAAA,IAAA,KAAA,EAsEA,OAlEA,SAAA,EAAA,EAAA,GAEA,GAAA,oBAAA,OAAA,UAAA,SAAA,KAAA,GACA,OAAA,EAAA,KAAA,EAAA,EAAA,GAEA,IAOA,EAAA,EAAA,EAAA,EAPA,EAAA,GACA,GAAA,EAAA,WAAA,IAAA,KAAA,EAAA,UAAA,IAAA,KAAA,EAAA,SAAA,IAAA,KACA,EAAA,OAAA,IAAA,IAEA,EAAA,EAEA,EAAA,IAAA,OAAA,EAAA,OAAA,EAAA,KAgBA,IAdA,GAAA,GACA,IAEA,EAAA,IAAA,OAAA,IAAA,EAAA,OAAA,WAAA,IASA,EAAA,IAAA,GAAA,IAAA,EACA,IAAA,GACA,EAAA,EAAA,KAAA,QAEA,EAAA,EAAA,MAAA,EAAA,GAAA,QACA,IACA,EAAA,KAAA,EAAA,MAAA,EAAA,EAAA,SAGA,GAAA,EAAA,OAAA,GACA,EAAA,GAAA,QAAA,EAAA,WACA,IAAA,IAAA,EAAA,EAAA,EAAA,UAAA,OAAA,EAAA,IACA,UAAA,KAAA,IACA,EAAA,GAAA,KAKA,EAAA,OAAA,GAAA,EAAA,MAAA,EAAA,QACA,MAAA,UAAA,KAAA,MAAA,EAAA,EAAA,MAAA,IAEA,EAAA,EAAA,GAAA,OACA,EAAA,EACA,EAAA,QAAA,KAIA,EAAA,YAAA,EAAA,OACA,EAAA,YAUA,OAPA,IAAA,EAAA,QACA,GAAA,EAAA,KAAA,KACA,EAAA,KAAA,IAGA,EAAA,KAAA,EAAA,MAAA,IAEA,EAAA,OAAA,EAAA,EAAA,MAAA,EAAA,GAAA,GAtEA;;AC9BA,IAAA,EAAA,GAAA,QAEA,OAAA,QAAA,SAAA,EAAA,GACA,GAAA,EAAA,OAAA,EAAA,QAAA,GACA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,SAAA,EACA,GAAA,EAAA,KAAA,EAAA,OAAA,EAEA,OAAA;;ACPA,IAAA,EAAA,QAAA,WAIA,SAAA,EAAA,GACA,IAAA,EAAA,EAAA,UAEA,GAAA,EACA,OAAA,EAGA,IAAA,EAAA,CACA,IAAA,EACA,OAAA,EACA,SAAA,EACA,OAiCA,SAAA,GACA,OAAA,EAAA,IACA,EAAA,IACA,IAEA,EAAA,IACA,IAtCA,SA0CA,WACA,OAAA,EAAA,WA1CA,OAAA,EACA,KA4CA,SAAA,GAEA,OADA,IACA,IAAA,OA3CA,OAAA,EAEA,SAAA,EAAA,GACA,IAAA,EAAA,IACA,EAAA,EAAA,IAAA,IAGA,EAAA,KAAA,GACA,EAAA,IAGA,SAAA,EAAA,GACA,IAAA,EAAA,IACA,EAAA,EAAA,EAAA,IAEA,IAAA,IAIA,EAAA,OAAA,EAAA,GACA,EAAA,IAGA,SAAA,EAAA,GACA,OAAA,EAAA,IAAA,IAAA,EAsBA,SAAA,IAGA,OAAA,EAFA,EAAA,UAEA,MAAA,KAAA,GAGA,SAAA,EAAA,GACA,IAAA,EAAA,EAAA,OAEA,EAAA,UAAA,EAAA,KAAA,KACA,EAAA,OAAA,EAEA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,OAAA,IACA,EAAA,GAAA,EAAA,UAGA,EAAA,IAIA,SAAA,EAAA,EAAA,GAEA,IADA,IAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,OAAA,IACA,EAAA,EAAA,KAAA,EAAA,KAAA,EAAA,IAEA,OAAA,EAGA,SAAA,EAAA,GACA,QAAA,EA9FA,OAAA,QAAA;;;;ACHA,IAAA,EAAA,QAAA,iBACA,EAAA,QAAA,cAEA,EAAA,oBAAA,OAAA,QAAA,gBAAA,OACA,EAAA,EAAA,SACA,EAAA,EAAA,KAEA,SAAA,IAEA,IAAA,EAAA,GAEA,SAAA,IACA,IAAA,EAAA,GAAA,MAAA,KAAA,WAAA,EAAA,KACA,SAAA,EAAA,GACA,IAAA,EAMA,EAeA,GAAA,MAAA,QAEA,GAAA,iBAAA,EACA,EAGA,EAAA,YAAA,EAAA,EAAA,eAAA,KArBA,EAAA,EAmBA,EAnBA,oBACA,QAAA,KAAA,EAAA,MACA,EAAA,EAAA,cAAA,QACA,EAAA,EAAA,SAAA,GACA,IAAA,EAAA,EAAA,UAAA,EAAA,EAAA,QACA,IACA,EAEA,MAAA,EAAA,GACA,EAAA,GAAA,IAAA,GACA,MAAA,EAAA,IACA,EAAA,aAAA,KAAA,GAJA,EAAA,EAAA,cAAA,YAgBA,GAAA,iBAAA,GACA,kBAAA,GACA,aAAA,MACA,aAAA,OACA,EAAA,YAAA,EAAA,EAAA,eAAA,EAAA,kBAGA,GAAA,EAAA,GACA,EAAA,EAAA,QACA,GAAA,EAAA,GACA,EAAA,YAAA,EAAA,QACA,GAAA,aAAA,EACA,EAAA,YAAA,EAAA,QACA,GAAA,iBAAA,EACA,IAAA,IAAA,KAAA,EACA,GAAA,mBAAA,EAAA,GACA,SAAA,KAAA,GACA,SAAA,EAAA,GACA,EAAA,kBACA,EAAA,iBAAA,EAAA,UAAA,GAAA,EAAA,IAAA,GACA,EAAA,KAAA,WACA,EAAA,oBAAA,EAAA,UAAA,GAAA,EAAA,IAAA,OAGA,EAAA,YAAA,EAAA,EAAA,IACA,EAAA,KAAA,WACA,EAAA,YAAA,EAAA,EAAA,OATA,CAYA,EAAA,IAGA,EAAA,GAAA,EAAA,KACA,EAAA,KAAA,EAAA,GAAA,SAAA,GACA,EAAA,GAAA,WAIA,GAAA,UAAA,EACA,GAAA,iBAAA,EAAA,GACA,EAAA,MAAA,QAAA,EAAA,QAEA,IAAA,IAAA,KAAA,EAAA,IAAA,SAAA,EAAA,GACA,GAAA,mBAAA,EAEA,EAAA,MAAA,YAAA,EAAA,KACA,EAAA,KAAA,EAAA,SAAA,GACA,EAAA,MAAA,YAAA,EAAA,WAGA,IAAA,EAAA,EAAA,GAAA,GAAA,MAAA,yBACA,EACA,EAAA,MAAA,YAAA,EAAA,EAAA,GAAA,aAEA,EAAA,MAAA,YAAA,EAAA,EAAA,GAAA,IAZA,CAcA,EAAA,EAAA,GAAA,SAEA,GAAA,UAAA,EACA,IAAA,IAAA,KAAA,EAAA,GACA,EAAA,aAAA,EAAA,EAAA,GAAA,QAGA,UAAA,EAAA,OAAA,EAAA,GACA,EAAA,aAAA,EAAA,EAAA,IAEA,EAAA,GAAA,EAAA,QAGA,GAAA,mBAAA,EAAA,CAEA,EAAA,IACA,EAAA,YAAA,EAAA,EAAA,GAAA,EAAA,EAAA,eAAA,IAEA,EAAA,KAAA,EAAA,SAAA,GACA,EAAA,IAAA,EAAA,eACA,EAAA,cAAA,aAAA,EAAA,GAAA,EAAA,GAEA,EAAA,YAAA,KAIA,OAAA,EAEA,KAAA,EAAA,QACA,EAAA,EAAA,SAEA,OAAA,EAUA,OAPA,EAAA,QAAA,WACA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,OAAA,IACA,EAAA,KAEA,EAAA,OAAA,GAGA,EAGA,IAAA,EAAA,OAAA,QAAA,IAGA,SAAA,EAAA,GACA,OAAA,GAAA,EAAA,UAAA,EAAA,SAGA,SAAA,EAAA,EAAA,GACA,GAAA,EAAA,QAAA,OAAA,EAAA,QAAA,GACA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,OAAA,IAAA,EAAA,EAAA,GAAA,GAGA,SAAA,EAAA,GACA,MAAA,kBAAA,OAAA,UAAA,SAAA,KAAA,GAZA,EAAA,QAAA;;AC5FA,aAAA,IAAA,EAAA,MAAA,KAAA,iBAAA,SAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,IAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IApDA,IAAA,EAAA,QAAA,mBACA,EAAA,EAAA,QAAA,gBAkBA,SAAgB,EAAM,EAAW,GAC/B,EAAO,GAAQ,QAEX,IAAA,EAAW,GAET,EAAS,gBAAgB,YACzB,EAAA,EAAA,MAAA,MAAC,EAAA,EAAA,GAAK,EAAA,EAAA,GACR,GAAA,EAAK,CACD,IAAA,EAAY,IAAI,OAAU,EAAG,OAAO,EAAO,MAC3C,EAAc,EAAO,OAAO,SAAC,GAAM,OAAA,EAAU,KAAK,EAAE,SAC1C,OAAS,IACvB,EAAW,EAAY,KAAK,SAAC,EAAI,GAAO,OAAA,EAAG,cACxC,EAAI,EAAG,aAAe,EAAI,IAAG,GAAG,MAGnC,IAAC,EAAU,CACP,IACA,EADA,EAAY,IAAI,OAAO,IAAI,EAAO,MAClC,EAAc,EAAO,OAAO,SAAC,GAAM,OAAA,EAAU,KAAK,EAAE,SAC1C,OAAS,IACvB,EAAW,EAAY,KAAK,SAAC,EAAI,GAAO,OAAA,EAAG,cACxC,EAAI,EAAG,aAAe,EAAI,IAAG,GAAG,MAInC,GAAA,EAAU,CACN,IAAA,EAAI,IAAI,yBAAyB,GACvC,EAAE,KAAO,EACT,gBAAgB,MAAM,IApC1B,OAAO,SAAS,QAAQ,SAAS,MAAQ,CACvC,KAAM,OACN,OAAQ,EAAA,qBAAqB,UAAW,SAAC,EAAG,GACnC,OAAA,EAAA,QAAE,SAAU,CAAC,MAAO,CACd,QAAA,kBAAiB,EAAM,GAAK,GAAC,OAAM,EAAM,MAAQ,IAAE,MAC5D,GAAG,aAIX,QAAA,MAAA,EA+BA,OAAO,MAAQ,EAEf,SAAS,KAAK,iBAAiB,UAAW,SAAC,GACrC,GAAa,SAAb,EAAI,KAAiB,CACjB,IAAA,EAAI,eACN,GACF,EAAM,EAAE","file":"markdown.js","sourceRoot":"../src","sourcesContent":["\"use strict\";\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction eqDictParser(s) {\n    var _a, _b;\n    var k = \"\";\n    var v = \"\";\n    var output = {};\n    while (s.length > 0) {\n        _a = __read(eqDictConsume(s), 2), k = _a[0], s = _a[1];\n        if (k) {\n            if (s[0] === \"=\") {\n                _b = __read(eqDictConsume(s), 2), v = _b[0], s = _b[1];\n                output[k] = v;\n            }\n            else {\n                output[k] = \"\";\n            }\n            k = \"\";\n        }\n    }\n    return output;\n}\nexports.eqDictParser = eqDictParser;\nfunction eqDictConsume(s) {\n    s = s.replace(/^[ =,\\s]+/, \"\");\n    if (!s) {\n        return [\"\", \"\"];\n    }\n    else {\n        if (s[0] === '\"' || s[0] === \"'\") {\n            var iSplitter_1 = s.length;\n            s.split(\"\").forEach(function (c, i) {\n                if (i > 0) {\n                    if (c === s[0] && s.substr(i - 1, 1) !== \"\\\\\" && iSplitter_1 === s.length) {\n                        iSplitter_1 = i;\n                    }\n                }\n            });\n            return [s.substr(1, iSplitter_1 - 1), s.substr(iSplitter_1 + 1)];\n        }\n        else {\n            var iSplitter_2 = s.length;\n            s.split(\"\").forEach(function (c, i) {\n                if (/[=,\\s]/.test(c) && iSplitter_2 === s.length) {\n                    iSplitter_2 = i;\n                }\n            });\n            return [s.substr(0, iSplitter_2), s.substr(iSplitter_2)];\n        }\n    }\n}\n","\"use strict\";\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction stripIndent(s) {\n    var e_1, _a;\n    var indents = [];\n    try {\n        for (var _b = __values(s.split(\"\\n\")), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var r = _c.value;\n            if (r.trim()) {\n                var m = /^ */.exec(r);\n                if (m) {\n                    indents.push(m[0].length);\n                }\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    if (indents.length === 0) {\n        indents.push(0);\n    }\n    var indent = Math.min.apply(Math, __spread(indents));\n    return s.split(\"\\n\").map(function (r) { return r.substr(indent); }).join(\"\\n\");\n}\nexports.stripIndent = stripIndent;\n","\"use strict\";\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar eqdict_1 = require(\"./eqdict\");\nvar util_1 = require(\"./util\");\nfunction createIndentedFilter(tag, fn) {\n    return function (text) {\n        var e_1, _a, e_2, _b, e_3, _c;\n        var replacement = [];\n        var lastPos = 0;\n        var currentPos = text.indexOf(tag);\n        while (currentPos !== -1) {\n            var indentStr = text.substr(lastPos, currentPos - lastPos).match(/(?:^|\\n)(.*)$/);\n            var indentSize = indentStr ? indentStr[1].length : 0;\n            lastPos = currentPos + tag.length;\n            var nextSegment = text.substr(lastPos);\n            var bracketDepth = 0;\n            var eqDictStr = [];\n            try {\n                for (var _d = (e_1 = void 0, __values(nextSegment.split(\"\"))), _e = _d.next(); !_e.done; _e = _d.next()) {\n                    var c = _e.value;\n                    if (c === \"(\") {\n                        bracketDepth++;\n                        continue;\n                    }\n                    else if (c === \")\") {\n                        bracketDepth--;\n                    }\n                    if (bracketDepth > 0) {\n                        eqDictStr.push(c);\n                    }\n                    else if (bracketDepth <= 0) {\n                        break;\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            var attrs = {};\n            if (eqDictStr.length > 0) {\n                var eqDict = eqDictStr.join(\"\");\n                attrs = eqdict_1.eqDictParser(eqDict);\n                lastPos += eqDict.length + 2;\n                nextSegment = text.substr(lastPos);\n            }\n            if (nextSegment[0] === \".\") {\n                var isFirst = true;\n                var contents = [];\n                try {\n                    for (var _f = (e_2 = void 0, __values(nextSegment.split(\"\\n\"))), _g = _f.next(); !_g.done; _g = _f.next()) {\n                        var row = _g.value;\n                        if (!isFirst) {\n                            if (!/\\S/.test(row) || /^\\s+$/.test(row.substr(0, indentSize + 1))) {\n                                contents.push(row);\n                            }\n                            else {\n                                break;\n                            }\n                        }\n                        lastPos += row.length + 1;\n                        isFirst = false;\n                    }\n                }\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                finally {\n                    try {\n                        if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n                    }\n                    finally { if (e_2) throw e_2.error; }\n                }\n                replacement.push({\n                    s: util_1.stripIndent(contents.join(\"\\n\")),\n                    attrs: attrs,\n                    start: currentPos,\n                    end: lastPos\n                });\n            }\n            else {\n                var row = nextSegment.split(\"\\n\")[0];\n                var endIndex = row.indexOf(\"^^\");\n                if (endIndex !== -1) {\n                    row = row.substr(0, endIndex);\n                    lastPos += row.length + 2;\n                }\n                else {\n                    lastPos += row.length;\n                }\n                replacement.push({\n                    s: util_1.stripIndent(row),\n                    attrs: attrs,\n                    start: currentPos,\n                    end: lastPos\n                });\n            }\n            currentPos = text.indexOf(tag, lastPos + 1);\n        }\n        ;\n        var segments = [];\n        var start = 0;\n        try {\n            for (var replacement_1 = __values(replacement), replacement_1_1 = replacement_1.next(); !replacement_1_1.done; replacement_1_1 = replacement_1.next()) {\n                var r = replacement_1_1.value;\n                segments.push(text.substr(start, r.start - start));\n                segments.push(fn(r.s, r.attrs));\n                start = r.end;\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (replacement_1_1 && !replacement_1_1.done && (_c = replacement_1.return)) _c.call(replacement_1);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        segments.push(text.substr(start));\n        return segments.join(\"\");\n    };\n}\nexports.createIndentedFilter = createIndentedFilter;\n","/*!\n * Cross-Browser Split 1.1.1\n * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>\n * Available under the MIT License\n * ECMAScript compliant, uniform cross-browser split method\n */\n\n/**\n * Splits a string into an array of strings using a regex or string separator. Matches of the\n * separator are not included in the result array. However, if `separator` is a regex that contains\n * capturing groups, backreferences are spliced into the result each time `separator` is matched.\n * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably\n * cross-browser.\n * @param {String} str String to split.\n * @param {RegExp|String} separator Regex or string to use for separating the string.\n * @param {Number} [limit] Maximum number of items to include in the result array.\n * @returns {Array} Array of substrings.\n * @example\n *\n * // Basic use\n * split('a b c d', ' ');\n * // -> ['a', 'b', 'c', 'd']\n *\n * // With limit\n * split('a b c d', ' ', 2);\n * // -> ['a', 'b']\n *\n * // Backreferences in result array\n * split('..word1 word2..', /([a-z]+)(\\d+)/i);\n * // -> ['..', 'word', '1', ' ', 'word', '2', '..']\n */\nmodule.exports = (function split(undef) {\n\n  var nativeSplit = String.prototype.split,\n    compliantExecNpcg = /()??/.exec(\"\")[1] === undef,\n    // NPCG: nonparticipating capturing group\n    self;\n\n  self = function(str, separator, limit) {\n    // If `separator` is not a regex, use `nativeSplit`\n    if (Object.prototype.toString.call(separator) !== \"[object RegExp]\") {\n      return nativeSplit.call(str, separator, limit);\n    }\n    var output = [],\n      flags = (separator.ignoreCase ? \"i\" : \"\") + (separator.multiline ? \"m\" : \"\") + (separator.extended ? \"x\" : \"\") + // Proposed for ES6\n      (separator.sticky ? \"y\" : \"\"),\n      // Firefox 3+\n      lastLastIndex = 0,\n      // Make `global` and avoid `lastIndex` issues by working with a copy\n      separator = new RegExp(separator.source, flags + \"g\"),\n      separator2, match, lastIndex, lastLength;\n    str += \"\"; // Type-convert\n    if (!compliantExecNpcg) {\n      // Doesn't need flags gy, but they don't hurt\n      separator2 = new RegExp(\"^\" + separator.source + \"$(?!\\\\s)\", flags);\n    }\n    /* Values for `limit`, per the spec:\n     * If undefined: 4294967295 // Math.pow(2, 32) - 1\n     * If 0, Infinity, or NaN: 0\n     * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;\n     * If negative number: 4294967296 - Math.floor(Math.abs(limit))\n     * If other: Type-convert, then use the above rules\n     */\n    limit = limit === undef ? -1 >>> 0 : // Math.pow(2, 32) - 1\n    limit >>> 0; // ToUint32(limit)\n    while (match = separator.exec(str)) {\n      // `separator.lastIndex` is not reliable cross-browser\n      lastIndex = match.index + match[0].length;\n      if (lastIndex > lastLastIndex) {\n        output.push(str.slice(lastLastIndex, match.index));\n        // Fix browsers whose `exec` methods don't consistently return `undefined` for\n        // nonparticipating capturing groups\n        if (!compliantExecNpcg && match.length > 1) {\n          match[0].replace(separator2, function() {\n            for (var i = 1; i < arguments.length - 2; i++) {\n              if (arguments[i] === undef) {\n                match[i] = undef;\n              }\n            }\n          });\n        }\n        if (match.length > 1 && match.index < str.length) {\n          Array.prototype.push.apply(output, match.slice(1));\n        }\n        lastLength = match[0].length;\n        lastLastIndex = lastIndex;\n        if (output.length >= limit) {\n          break;\n        }\n      }\n      if (separator.lastIndex === match.index) {\n        separator.lastIndex++; // Avoid an infinite loop\n      }\n    }\n    if (lastLastIndex === str.length) {\n      if (lastLength || !separator.test(\"\")) {\n        output.push(\"\");\n      }\n    } else {\n      output.push(str.slice(lastLastIndex));\n    }\n    return output.length > limit ? output.slice(0, limit) : output;\n  };\n\n  return self;\n})();\n","\nvar indexOf = [].indexOf;\n\nmodule.exports = function(arr, obj){\n  if (indexOf) return arr.indexOf(obj);\n  for (var i = 0; i < arr.length; ++i) {\n    if (arr[i] === obj) return i;\n  }\n  return -1;\n};","// contains, add, remove, toggle\nvar indexof = require('indexof')\n\nmodule.exports = ClassList\n\nfunction ClassList(elem) {\n    var cl = elem.classList\n\n    if (cl) {\n        return cl\n    }\n\n    var classList = {\n        add: add\n        , remove: remove\n        , contains: contains\n        , toggle: toggle\n        , toString: $toString\n        , length: 0\n        , item: item\n    }\n\n    return classList\n\n    function add(token) {\n        var list = getTokens()\n        if (indexof(list, token) > -1) {\n            return\n        }\n        list.push(token)\n        setTokens(list)\n    }\n\n    function remove(token) {\n        var list = getTokens()\n            , index = indexof(list, token)\n\n        if (index === -1) {\n            return\n        }\n\n        list.splice(index, 1)\n        setTokens(list)\n    }\n\n    function contains(token) {\n        return indexof(getTokens(), token) > -1\n    }\n\n    function toggle(token) {\n        if (contains(token)) {\n            remove(token)\n            return false\n        } else {\n            add(token)\n            return true\n        }\n    }\n\n    function $toString() {\n        return elem.className\n    }\n\n    function item(index) {\n        var tokens = getTokens()\n        return tokens[index] || null\n    }\n\n    function getTokens() {\n        var className = elem.className\n\n        return filter(className.split(\" \"), isTruthy)\n    }\n\n    function setTokens(list) {\n        var length = list.length\n\n        elem.className = list.join(\" \")\n        classList.length = length\n\n        for (var i = 0; i < list.length; i++) {\n            classList[i] = list[i]\n        }\n\n        delete list[length]\n    }\n}\n\nfunction filter (arr, fn) {\n    var ret = []\n    for (var i = 0; i < arr.length; i++) {\n        if (fn(arr[i])) ret.push(arr[i])\n    }\n    return ret\n}\n\nfunction isTruthy(value) {\n    return !!value\n}\n","var split = require('browser-split')\nvar ClassList = require('class-list')\n\nvar w = typeof window === 'undefined' ? require('html-element') : window\nvar document = w.document\nvar Text = w.Text\n\nfunction context () {\n\n  var cleanupFuncs = []\n\n  function h() {\n    var args = [].slice.call(arguments), e = null\n    function item (l) {\n      var r\n      function parseClass (string) {\n        // Our minimal parser doesn’t understand escaping CSS special\n        // characters like `#`. Don’t use them. More reading:\n        // https://mathiasbynens.be/notes/css-escapes .\n\n        var m = split(string, /([\\.#]?[^\\s#.]+)/)\n        if(/^\\.|#/.test(m[1]))\n          e = document.createElement('div')\n        forEach(m, function (v) {\n          var s = v.substring(1,v.length)\n          if(!v) return\n          if(!e)\n            e = document.createElement(v)\n          else if (v[0] === '.')\n            ClassList(e).add(s)\n          else if (v[0] === '#')\n            e.setAttribute('id', s)\n        })\n      }\n\n      if(l == null)\n        ;\n      else if('string' === typeof l) {\n        if(!e)\n          parseClass(l)\n        else\n          e.appendChild(r = document.createTextNode(l))\n      }\n      else if('number' === typeof l\n        || 'boolean' === typeof l\n        || l instanceof Date\n        || l instanceof RegExp ) {\n          e.appendChild(r = document.createTextNode(l.toString()))\n      }\n      //there might be a better way to handle this...\n      else if (isArray(l))\n        forEach(l, item)\n      else if(isNode(l))\n        e.appendChild(r = l)\n      else if(l instanceof Text)\n        e.appendChild(r = l)\n      else if ('object' === typeof l) {\n        for (var k in l) {\n          if('function' === typeof l[k]) {\n            if(/^on\\w+/.test(k)) {\n              (function (k, l) { // capture k, l in the closure\n                if (e.addEventListener){\n                  e.addEventListener(k.substring(2), l[k], false)\n                  cleanupFuncs.push(function(){\n                    e.removeEventListener(k.substring(2), l[k], false)\n                  })\n                }else{\n                  e.attachEvent(k, l[k])\n                  cleanupFuncs.push(function(){\n                    e.detachEvent(k, l[k])\n                  })\n                }\n              })(k, l)\n            } else {\n              // observable\n              e[k] = l[k]()\n              cleanupFuncs.push(l[k](function (v) {\n                e[k] = v\n              }))\n            }\n          }\n          else if(k === 'style') {\n            if('string' === typeof l[k]) {\n              e.style.cssText = l[k]\n            }else{\n              for (var s in l[k]) (function(s, v) {\n                if('function' === typeof v) {\n                  // observable\n                  e.style.setProperty(s, v())\n                  cleanupFuncs.push(v(function (val) {\n                    e.style.setProperty(s, val)\n                  }))\n                } else\n                  var match = l[k][s].match(/(.*)\\W+!important\\W*$/);\n                  if (match) {\n                    e.style.setProperty(s, match[1], 'important')\n                  } else {\n                    e.style.setProperty(s, l[k][s])\n                  }\n              })(s, l[k][s])\n            }\n          } else if(k === 'attrs') {\n            for (var v in l[k]) {\n              e.setAttribute(v, l[k][v])\n            }\n          }\n          else if (k.substr(0, 5) === \"data-\") {\n            e.setAttribute(k, l[k])\n          } else {\n            e[k] = l[k]\n          }\n        }\n      } else if ('function' === typeof l) {\n        //assume it's an observable!\n        var v = l()\n        e.appendChild(r = isNode(v) ? v : document.createTextNode(v))\n\n        cleanupFuncs.push(l(function (v) {\n          if(isNode(v) && r.parentElement)\n            r.parentElement.replaceChild(v, r), r = v\n          else\n            r.textContent = v\n        }))\n      }\n\n      return r\n    }\n    while(args.length)\n      item(args.shift())\n\n    return e\n  }\n\n  h.cleanup = function () {\n    for (var i = 0; i < cleanupFuncs.length; i++){\n      cleanupFuncs[i]()\n    }\n    cleanupFuncs.length = 0\n  }\n\n  return h\n}\n\nvar h = module.exports = context()\nh.context = context\n\nfunction isNode (el) {\n  return el && el.nodeName && el.nodeType\n}\n\nfunction forEach (arr, fn) {\n  if (arr.forEach) return arr.forEach(fn)\n  for (var i = 0; i < arr.length; i++) fn(arr[i], i)\n}\n\nfunction isArray (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]'\n}\n\n\n","import { createIndentedFilter } from 'indented-filter'\nimport h from 'hyperscript'\n\ndeclare global {\n  interface Window {\n    revealMd: any;\n    speak(s: string, lang?: string): void;\n  }\n}\n\nwindow.revealMd.plugins.markdown.speak = {\n  type: 'lang',\n  filter: createIndentedFilter('^^speak', (s, attrs) => {\n    return h('.speak', {attrs: {\n      'onclick': `window.speak('${attrs.s || s}', ${attrs.lang || ''})`\n    }}, s).outerHTML\n  })\n}\n\nexport function speak(s: string, lang?: string) {\n  lang = lang || \"zh-CN\";\n\n  let trueLang = \"\";\n\n  const voices = speechSynthesis.getVoices();\n  const [la1, la2] = lang.split(/-_/);\n  if (la2) {\n    const langRegex = new RegExp(`${la1}[-_]${la2}`, \"i\");\n    const matchedLang = voices.filter((v) => langRegex.test(v.lang));\n    if (matchedLang.length > 0) {\n      trueLang = matchedLang.sort((v1, v2) => v1.localService\n      ? -1 : v2.localService ? 1 : 0)[0].lang;\n    }\n  }\n  if (!trueLang) {\n    const langRegex = new RegExp(`^${la1}`, \"i\");\n    const matchedLang = voices.filter((v) => langRegex.test(v.lang));\n    if (matchedLang.length > 0) {\n      trueLang = matchedLang.sort((v1, v2) => v1.localService\n      ? -1 : v2.localService ? 1 : 0)[0].lang;\n    }\n  }\n\n  if (trueLang) {\n    const u = new SpeechSynthesisUtterance(s);\n    u.lang = trueLang;\n    speechSynthesis.speak(u);\n  }\n}\n\nwindow.speak = speak;\n\ndocument.body.addEventListener(\"keydown\", (evt) => {\n  if (evt.code === \"KeyS\") {\n    const s = getSelection();\n    if (s) {\n      speak(s.toString());\n    }\n  }\n});\n"]}